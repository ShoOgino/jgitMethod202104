	/**
	 * Execute common ancestor negotiation and fetch the objects.
	 *
	 * @param monitor
	 *            progress monitor to receive status updates. If the monitor is
	 *            the {@link org.eclipse.jgit.lib.NullProgressMonitor#INSTANCE}, then the no-progress
	 *            option enabled.
	 * @param want
	 *            the advertised remote references the caller wants to fetch.
	 * @param have
	 *            additional objects to assume that already exist locally. This
	 *            will be added to the set of objects reachable from the
	 *            destination repository's references.
	 * @param outputStream
	 *            ouputStream to write sideband messages to
	 * @throws org.eclipse.jgit.errors.TransportException
	 *             if any exception occurs.
	 * @since 3.0
	 */
	protected void doFetch(final ProgressMonitor monitor,
			final Collection<Ref> want, final Set<ObjectId> have,
			OutputStream outputStream) throws TransportException {
		try {
			noProgress = monitor == NullProgressMonitor.INSTANCE;

			markRefsAdvertised();
			markReachable(have, maxTimeWanted(want));

			if (statelessRPC) {
				state = new TemporaryBuffer.Heap(Integer.MAX_VALUE);
				pckState = new PacketLineOut(state);
			}

			if (TransferConfig.ProtocolVersion.V2
					.equals(getProtocolVersion())) {
				sideband = true;
				noDone = true;
				multiAck = MultiAck.DETAILED;
				setFetchOptions();
				PacketLineOut output = statelessRPC ? pckState : pckOut;
				output.writeString(
						"command=" + GitProtocolConstants.COMMAND_FETCH); //$NON-NLS-1$
				// Capabilities are sent as command arguments in protocol V2
				String agent = UserAgent.get();
				if (agent != null
						&& isCapableOf(GitProtocolConstants.OPTION_AGENT)) {
					output.writeString(
							GitProtocolConstants.OPTION_AGENT + '=' + agent);
				}
				output.writeDelim();
				// Arguments
				for (String capability : getCapabilitiesV2()) {
					output.writeString(capability);
				}
			}
			if (sendWants(want)) {
				negotiate(monitor);

				walk.dispose();
				reachableCommits = null;
				state = null;
				pckState = null;

				if (TransferConfig.ProtocolVersion.V2
						.equals(getProtocolVersion())) {
					String header = pckIn.readString();
					if (PacketLineIn.isEnd(header)) {
						// No packfile following.
						return;
					}

					if (header.startsWith("ERR ")) { //$NON-NLS-1$
						// Protocol V2 may give us an error here (for instance,
						// invalid want)
						throw new PackProtocolException(header.substring(4));
					}
					if (!GitProtocolConstants.SECTION_PACKFILE.equals(header)) {
						throw new PackProtocolException(MessageFormat.format(
								JGitText.get().expectedGot,
								GitProtocolConstants.SECTION_PACKFILE, header));
					}
				}
				receivePack(monitor, outputStream);
			}
		} catch (CancelledException ce) {
			close();
			return; // Caller should test (or just know) this themselves.
		} catch (IOException | RuntimeException err) {
			close();
			throw new TransportException(err.getMessage(), err);
		}
	}

