	/**
	 * For each of the {@code want}s, which represent the tip commit of each
	 * branch, set up an initial {@link BitmapBuilder}. Reuse previously built
	 * bitmaps if possible.
	 *
	 * @param rw
	 *            a {@link RevWalk} to find reachable objects in this repository
	 * @param expectedCommitCount
	 *            expected count of commits. The actual count may be less due to
	 *            unreachable garbage.
	 * @param excludeFromBitmapSelection
	 *            commits that should be excluded from bitmap selection
	 * @return a {@link CommitSelectionHelper} containing bitmaps for the tip
	 *         commits
	 * @throws IncorrectObjectTypeException
	 *             if any of the processed objects is not a commit
	 * @throws IOException
	 *             on errors reading pack or index files
	 * @throws MissingObjectException
	 *             if an expected object is missing
	 */
	private CommitSelectionHelper setupTipCommitBitmaps(RevWalk rw,
			int expectedCommitCount,
			Set<? extends ObjectId> excludeFromBitmapSelection)
			throws IncorrectObjectTypeException, IOException,
			MissingObjectException {
		BitmapBuilder reuse = commitBitmapIndex.newBitmapBuilder();
		List<BitmapCommit> reuseCommits = new ArrayList<>();
		for (PackBitmapIndexRemapper.Entry entry : bitmapRemapper) {
			// More recent commits did not have the reuse flag set, so skip them
			if ((entry.getFlags() & FLAG_REUSE) != FLAG_REUSE) {
				continue;
			}
			RevObject ro = rw.peel(rw.parseAny(entry));
			if (!(ro instanceof RevCommit)) {
				continue;
			}

			RevCommit rc = (RevCommit) ro;
			reuseCommits.add(new BitmapCommit(rc, false, entry.getFlags()));
			if (!reuse.contains(rc)) {
				EWAHCompressedBitmap bitmap = bitmapRemapper.ofObjectType(
						bitmapRemapper.getBitmap(rc), Constants.OBJ_COMMIT);
				reuse.or(new CompressedBitmap(bitmap, commitBitmapIndex));
			}
		}

		// Add branch tips that are not represented in old bitmap indices. Set
		// up the RevWalk to walk the new commits not in the old packs.
		List<BitmapBuilderEntry> tipCommitBitmaps = new ArrayList<>(
				want.size());
		Set<RevCommit> peeledWant = new HashSet<>(want.size());
		for (AnyObjectId objectId : want) {
			RevObject ro = rw.peel(rw.parseAny(objectId));
			if (!(ro instanceof RevCommit) || reuse.contains(ro)
					|| excludeFromBitmapSelection.contains(ro)) {
				continue;
			}

			RevCommit rc = (RevCommit) ro;
			peeledWant.add(rc);
			rw.markStart(rc);

			BitmapBuilder bitmap = commitBitmapIndex.newBitmapBuilder();
			bitmap.addObject(rc, Constants.OBJ_COMMIT);
			tipCommitBitmaps.add(new BitmapBuilderEntry(rc, bitmap));
		}

		// Create a list of commits in reverse order (older to newer).
		// For each branch that contains the commit, mark its parents as being
		// in the bitmap.
		rw.setRevFilter(new NotInBitmapFilter(reuse));
		RevCommit[] commits = new RevCommit[expectedCommitCount];
		int pos = commits.length;
		RevCommit rc;
		while ((rc = rw.next()) != null && pos > 0) {
			commits[--pos] = rc;
			for (BitmapBuilderEntry entry : tipCommitBitmaps) {
				BitmapBuilder bitmap = entry.getBuilder();
				if (!bitmap.contains(rc)) {
					continue;
				}
				for (RevCommit c : rc.getParents()) {
					if (reuse.contains(c)) {
						continue;
					}
					bitmap.addObject(c, Constants.OBJ_COMMIT);
				}
			}
			pm.update(1);
		}

		// Sort the tip commit bitmaps. Find the one containing the most
		// commits, remove those commits from the remaining bitmaps, resort and
		// repeat.
		List<BitmapBuilderEntry> orderedTipCommitBitmaps = new ArrayList<>(
				tipCommitBitmaps.size());
		while (!tipCommitBitmaps.isEmpty()) {
			BitmapBuilderEntry largest =
					Collections.max(tipCommitBitmaps, ORDER_BY_CARDINALITY);
			tipCommitBitmaps.remove(largest);
			orderedTipCommitBitmaps.add(largest);

			// Update the remaining paths, by removing the objects from
			// the path that was just added.
			for (int i = tipCommitBitmaps.size() - 1; i >= 0; i--) {
				tipCommitBitmaps.get(i).getBuilder()
						.andNot(largest.getBuilder());
			}
		}

		return new CommitSelectionHelper(peeledWant, commits, pos,
				orderedTipCommitBitmaps, reuse, reuseCommits);
	}

